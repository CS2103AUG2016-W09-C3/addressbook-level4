# A0140155U
###### \java\guitests\DoneUndoneCommandTest.java
``` java
package guitests;

import guitests.guihandles.TaskCardHandle;
import org.junit.Test;
import seedu.address.logic.commands.AddCommand;
import seedu.address.logic.commands.DoneCommand;
import seedu.address.model.task.DatedTask;
import seedu.address.model.task.DoneFlag;
import seedu.address.model.task.ReadOnlyDatedTask;
import seedu.address.model.task.ReadOnlyTask;
import seedu.address.model.task.Task;
import seedu.address.commons.core.Messages;
import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.testutil.TestTask;
import seedu.address.testutil.TestUtil;

import static org.junit.Assert.assertTrue;
import static seedu.address.logic.commands.DoneCommand.MESSAGE_SUCCESS;

public class DoneUndoneCommandTest extends TaskBookGuiTest {


    @Test
    public void doneFirstTask() {
        assertDoneSuccess(1, td.getTypicalTasks());
    }
    
    @Test
    public void doneLastTask() {
        assertDoneSuccess(td.getTypicalTasks().length, td.getTypicalTasks());
    }
    
    @Test
    public void doneMiddleTask() {
        assertDoneSuccess(td.getTypicalTasks().length / 2, td.getTypicalTasks());
    }
    
    @Test
    public void doneDoneTask() {
        commandBox.runCommand("done 1");
        commandBox.runCommand("done 1");
        assertResultMessage("Task is already done.");
    }
    
    @Test
    public void doneInvalidTask() {
        commandBox.runCommand("done " + td.getTypicalTasks().length + 1);
        assertResultMessage("The task index provided is invalid");
    }
    
    @Test
    public void undoneFirstTask() {
        int targetIndex = 1;
        commandBox.runCommand("done " + targetIndex);
        assertUndoneSuccess(targetIndex, td.getTypicalTasks());
    }
    
    @Test
    public void undoneMiddleTask() {
        int targetIndex = td.getTypicalTasks().length / 2;
        commandBox.runCommand("done " + targetIndex);
        assertUndoneSuccess(targetIndex, td.getTypicalTasks());
    }
    
    @Test
    public void undoneLastTask() {
        int targetIndex = td.getTypicalTasks().length;
        commandBox.runCommand("done " + targetIndex);
        assertUndoneSuccess(targetIndex, td.getTypicalTasks());
    }

    @Test
    public void undoneUndoneTask() {
        commandBox.runCommand("undone 1");
        assertResultMessage("Task is already undone.");
    }

    @Test
    public void undoneInvalidTask() {
        commandBox.runCommand("undone " + td.getTypicalTasks().length + 1);
        assertResultMessage("The task index provided is invalid");
    }
    
    /**
     * Runs the done command to mark doneFlag of the task at specified index as done and confirms the result is correct.
     * @param targetIndexOneIndexed e.g. to mark the first task in the list as done, 1 should be given as the target index.
     * @param currentList A copy of the current list of tasks (before command).
     */
    private void assertDoneSuccess(int targetIndexOneIndexed, final TestTask[] currentList) {
        assertCommandSuccess(targetIndexOneIndexed, currentList, "done", DoneFlag.DONE);
    }

    /**
     * Runs the undone command to mark doneFlag of the task at specified index as undone and confirms the result is correct.
     * @param targetIndexOneIndexed e.g. to mark the first task in the list as undone, 1 should be given as the target index.
     * @param currentList A copy of the current list of tasks (before command).
     */
    private void assertUndoneSuccess(int targetIndexOneIndexed, final TestTask[] currentList) {
        assertCommandSuccess(targetIndexOneIndexed, currentList, "undone", DoneFlag.NOT_DONE);
    }
    
    private void assertCommandSuccess(int targetIndexOneIndexed, final TestTask[] currentList, String command, String doneFlag) {
        TestTask taskToDo = currentList[targetIndexOneIndexed-1]; //-1 because array uses zero indexing
        TestTask[] expectedResult = doTask(targetIndexOneIndexed, currentList, doneFlag);
        commandBox.runCommand(command + " " + targetIndexOneIndexed);

        //confirm the list now contains all previous tasks except the deleted task
        assertTrue(taskListPanel.isListMatching(expectedResult));

        //confirm the result message is correct
        assertResultMessage(String.format(MESSAGE_SUCCESS, doneFlag, taskToDo.getName()));
    }

    
    private TestTask[] doTask(int targetIndexOneIndexed, final TestTask[] currentList, String flag) {
        TestTask taskToDo = currentList[targetIndexOneIndexed-1]; //-1 because array uses zero indexing
        TestTask[] expectedRemainder = TestUtil.removeTaskFromList(currentList, targetIndexOneIndexed);
        try {
            taskToDo.setDoneFlag(new DoneFlag(flag));
        } catch (IllegalValueException e) {
            assert(false);
        }
        //expectedRemainder = TestUtil.addTasksToList(expectedRemainder, taskToDo);
        expectedRemainder = TestUtil.addTaskToListIndex(expectedRemainder, taskToDo, targetIndexOneIndexed - 1);
        return expectedRemainder;
    }
  
}
```
###### \java\guitests\FavoriteUnfavoriteCommandTest.java
``` java
package guitests;

import static org.junit.Assert.*;

import org.junit.Test;

import seedu.address.logic.commands.FavoriteCommand;
import seedu.address.logic.commands.UnfavoriteCommand;
import seedu.address.testutil.TestPreset;
import seedu.address.testutil.TestTask;
import seedu.address.testutil.TestUtil;

public class FavoriteUnfavoriteCommandTest extends TaskBookGuiTest  {


    private final String INVALID_MESSAGE_FAV = "Invalid command format! \n" + FavoriteCommand.MESSAGE_USAGE;
    private final String INVALID_MESSAGE_UNFAV = "Invalid command format! \n" + UnfavoriteCommand.MESSAGE_USAGE;
    private final String OUT_OF_RANGE_MESSAGE = "Index out of range.";
    
    @Test
    public void favorite_list() {
        commandBox.runCommand("favorite List c/list");
        presetListPanel.navigateToPreset("List");
        TestPreset[] expectedPresets = {new TestPreset("list", "List")};
        assertTrue(presetListPanel.isListMatching(expectedPresets));
        TestTask[] expectedList = td.getTypicalTasks();
        assertTrue(taskListPanel.isListMatching(expectedList));
    }
    
    @Test
    public void favorite_clear() {
        commandBox.runCommand("favorite Clear c/clear");
        presetListPanel.navigateToPreset("Clear");
        TestPreset[] expectedPresets = {new TestPreset("clear", "Clear")};
        assertTrue(presetListPanel.isListMatching(expectedPresets));
        TestTask[] expectedList = {};
        assertTrue(taskListPanel.isListMatching(expectedList));
    }
    
    @Test
    public void favorite_add() {
        TestTask personToAdd = td.nieceBirthdayMeal;
        commandBox.runCommand("favorite Add c/" + personToAdd.getAddCommand());
        TestPreset[] expectedPresets = {new TestPreset(personToAdd.getAddCommand(), "Add")};
        assertTrue(presetListPanel.isListMatching(expectedPresets));
        presetListPanel.navigateToPreset("Add");
        TestTask[] expectedList = TestUtil.addTasksToList(td.getTypicalTasks(), personToAdd);
        assertTrue(taskListPanel.isListMatching(expectedList));
    }
    
    @Test
    public void favorite_multipleCommands() {
        commandBox.runCommand("favorite Clear c/clear");
        commandBox.runCommand("favorite Undo c/undo");
        commandBox.runCommand("favorite Redo c/redo");
        TestPreset[] expectedPresets = {new TestPreset("clear", "Clear"),
                new TestPreset("undo", "Undo"),
                new TestPreset("redo", "Redo")};
        assertTrue(presetListPanel.isListMatching(expectedPresets));
        presetListPanel.navigateToPreset("Clear");
        TestTask[] expectedList = {};
        assertTrue(taskListPanel.isListMatching(expectedList));
        presetListPanel.navigateToPreset("Undo");
        assertTrue(taskListPanel.isListMatching(td.getTypicalTasks()));
        presetListPanel.navigateToPreset("Redo");
        assertTrue(taskListPanel.isListMatching(expectedList));
    }
    
    @Test
    public void favorite_invalid() {
        commandBox.runCommand("favorite c/no desc");
        assertResultMessage(INVALID_MESSAGE_FAV);
        commandBox.runCommand("favorite no command");
        assertResultMessage(INVALID_MESSAGE_FAV);
    }
    
    @Test
    public void favorite_unfavorite() {
        commandBox.runCommand("favorite List c/list");
        commandBox.runCommand("unfavorite 1");
        TestPreset[] expectedList = {};
        assertTrue(presetListPanel.isListMatching(expectedList));
    }
    
    @Test
    public void favorite_unfavorite_multiple() {
        commandBox.runCommand("favorite Redo c/redo");
        commandBox.runCommand("favorite Clear c/clear");
        commandBox.runCommand("favorite Undo c/undo");
        TestPreset[] expectedPresets = {new TestPreset("redo", "Redo"),
                new TestPreset("clear", "Clear"),
                new TestPreset("undo", "Undo")};
        assertTrue(presetListPanel.isListMatching(expectedPresets));
        commandBox.runCommand("unfavorite 1");
        expectedPresets = new TestPreset[] {new TestPreset("clear", "Clear"),
                new TestPreset("undo", "Undo")};
        assertTrue(presetListPanel.isListMatching(expectedPresets));
        commandBox.runCommand("unfavorite 2");
        expectedPresets = new TestPreset[] {new TestPreset("clear", "Clear")};
        assertTrue(presetListPanel.isListMatching(expectedPresets));
    }
    
    @Test
    public void unfavorite_invalid() {
        commandBox.runCommand("unfavorite");
        assertResultMessage(INVALID_MESSAGE_UNFAV);
        commandBox.runCommand("unfavorite 1");
        assertResultMessage(OUT_OF_RANGE_MESSAGE);
    }
    
}
```
###### \java\guitests\FilepathCommandTest.java
``` java
package guitests;

import static org.junit.Assert.*;

import java.util.regex.Matcher;

import org.junit.Test;

import seedu.address.logic.commands.FilepathCommand;
import seedu.address.testutil.TestUtil;

public class FilepathCommandTest extends TaskBookGuiTest {

    @Test
    public void wrongFilePaths() {
        assertFilepath("", false);
        assertFilepath(".xml", false);
        assertFilepath("noxml", false);
        assertFilepath("<>*.xml", false);
        assertFilepath("3:\\data.xml", false);
        assertFilepath(":\\data.xml", false);
        assertFilepath("DRIVE:\\data.xml", false);
        assertFilepath("\\data.xml", false);
        assertFilepath("file\\\\data.xml", false);
        assertFilepath("\\\\file\\\\data.xml", false);
    }
    
    @Test
    public void rightFilePaths() {
        assertFilepath("a.xml", true);
        assertFilepath("hello-world.xml", true);
        assertFilepath("D:\\file.xml", true);
        assertFilepath("folder\\folder\\folder\\file.xml", true);
        assertFilepath("C:\\folder\\folder\\folder\\file.xml", true);
    }
    
    private void assertFilepath(String filePath, boolean result) {
        final Matcher matcher = FilepathCommand.FILEPATH_REGEX.matcher(filePath);
        assert(matcher.matches() == result);
    }

    @Test
    public void noParam() {
        commandBox.runCommand("filepath");
        assertResultMessage(FilepathCommand.MESSAGE_INVALID_PATH);
    }

    @Test
    public void wrongParam() {
        commandBox.runCommand("filepath hello");
        assertResultMessage(FilepathCommand.MESSAGE_INVALID_PATH);
    }
    
    @Test
    public void simplePath() {
        String filePath = TestUtil.getFilePathInSandboxFolder("data.xml");
        assertFilePathChange(filePath);
    }
    
    @Test
    public void complexPath() {
        String filePath = TestUtil.getFilePathInSandboxFolder("data/data/data.xml");
        assertFilePathChange(filePath);
    }

    private void assertFilePathChange(String filePath) {
        commandBox.runCommand("filepath " + filePath);
        assertEquals(testApp.getSaveFilePath(), filePath);
    }
    
}
```
###### \java\guitests\guihandles\PresetCardHandle.java
``` java
package guitests.guihandles;

import guitests.GuiRobot;
import javafx.scene.Node;
import javafx.stage.Stage;
import seedu.address.model.CommandPreset;
import seedu.address.model.task.ReadOnlyTask;

/**
 * Provides a handle to a task card in the task list panel.
 */
public class PresetCardHandle extends GuiHandle {
    private static final String COMMAND_FIELD_ID = "#command";
    private static final String DESCRIPTION_FIELD_ID = "#description";

    private Node node;

    public PresetCardHandle(GuiRobot guiRobot, Stage primaryStage, Node node){
        super(guiRobot, primaryStage, null);
        this.node = node;
    }

    protected String getTextFromLabel(String fieldId) {
        return getTextFromLabel(fieldId, node);
    }

    public String getCommand() {
        return getTextFromLabel(COMMAND_FIELD_ID);
    }

    public String getDescription() {
        return getTextFromLabel(DESCRIPTION_FIELD_ID);
    }

    public boolean isSamePreset(CommandPreset preset){
        return getDescription().equals(preset.getDescription());
    }

    @Override
    public boolean equals(Object obj) {
        if(obj instanceof PresetCardHandle) {
            PresetCardHandle handle = (PresetCardHandle) obj;
            return getCommand().equals(handle.getCommand())
                    && getDescription().equals(handle.getDescription());
        }
        return super.equals(obj);
    }

    @Override
    public String toString() {
        return getCommand() + " " + getDescription();
    }
}
```
###### \java\guitests\guihandles\PresetListPanelHandle.java
``` java
package guitests.guihandles;


import guitests.GuiRobot;
import javafx.geometry.Point2D;
import javafx.scene.Node;
import javafx.scene.control.ListView;
import javafx.stage.Stage;
import seedu.address.TestApp;
import seedu.address.model.CommandPreset;
import seedu.address.model.task.ReadOnlyTask;
import seedu.address.testutil.TestUtil;

import java.util.List;
import java.util.Optional;
import java.util.Set;

import static org.junit.Assert.assertTrue;

/**
 * Provides a handle for the panel containing the preset list.
 */
public class PresetListPanelHandle extends GuiHandle {

    public static final int NOT_FOUND = -1;
    public static final String CARD_PANE_ID = "#presetCard";

    private static final String PRESET_LIST_VIEW_ID = "#presetListView";

    public PresetListPanelHandle(GuiRobot guiRobot, Stage primaryStage) {
        super(guiRobot, primaryStage, TestApp.APP_TITLE);
    }

    public List<CommandPreset> getSelectedPresets() {
        ListView<CommandPreset> presetList = getListView();
        return presetList.getSelectionModel().getSelectedItems();
    }

    public ListView<CommandPreset> getListView() {
        return (ListView<CommandPreset>) getNode(PRESET_LIST_VIEW_ID);
    }

    /**
     * Clicks on the ListView.
     */
    public void clickOnListView() {
        Point2D point= TestUtil.getScreenMidPoint(getListView());
        guiRobot.clickOn(point.getX(), point.getY());
    }
    
    /**
     * Returns true if the {@code presets} appear as the sub list (in that order) at position {@code startPosition}.
     */
    public boolean containsInOrder(int startPosition, CommandPreset... presets) {
        List<CommandPreset> presetsInList = getListView().getItems();

        // Return false if the list in panel is too short to contain the given list
        if (startPosition + presets.length > presetsInList.size()){
            return false;
        }

        // Return false if any of the persons doesn't match
        for (int i = 0; i < presets.length; i++) {
            if (!presetsInList.get(startPosition + i).getCommand().equals(presets[i].getCommand()) ||
                    !presetsInList.get(startPosition + i).getDescription().equals(presets[i].getDescription())){
                return false;
            }
        }

        return true;
    }
    
    public PresetCardHandle navigateToPreset(String description) {
        guiRobot.sleep(500); //Allow a bit of time for the list to be updated
        final Optional<CommandPreset> preset = getListView().getItems().stream().filter(p -> p.getDescription().equals(description)).findAny();
        if (!preset.isPresent()) {
            throw new IllegalStateException("Name not found: " + description);
        }

        return navigateToPreset(preset.get());
    }

    /**
     * Returns true if the list is showing the oreset details correctly and in correct order.
     * @param presets A list of person in the correct order.
     */
    public boolean isListMatching(CommandPreset... presets) {
        return this.isListMatching(0, presets);
    }
    
    /**
     * Returns true if the list is showing the presets details correctly and in correct order.
     * @param startPosition The starting position of the sub list.
     * @param presets A list of presets in the correct order.
     */
    public boolean isListMatching(int startPosition, CommandPreset... presets) throws IllegalArgumentException {
        if (presets.length + startPosition != getListView().getItems().size()) {
            throw new IllegalArgumentException("List size mismatched\n" +
                    "Expected " + (getListView().getItems().size() - 1) + " presets");
        }
        assertTrue(this.containsInOrder(startPosition, presets));
        for (int i = 0; i < presets.length; i++) {
            final int scrollTo = i + startPosition;
            guiRobot.interact(() -> getListView().scrollTo(scrollTo));
            guiRobot.sleep(200);
            if (!TestUtil.compareCardAndPreset(getPresetCardHandle(startPosition + i), presets[i])) {
                return false;
            }
        }
        return true;
    }
    
    /**
     * Navigates the listview to display and select the preset.
     */
    public PresetCardHandle navigateToPreset(CommandPreset preset) {
        int index = getPresetIndex(preset);

        guiRobot.interact(() -> {
            getListView().scrollTo(index);
            guiRobot.sleep(150);
            getListView().getSelectionModel().select(index);
        });
        guiRobot.sleep(100);
        return getPresetCardHandle(preset);
    }
    
    /**
     * Returns the position of the preset given, {@code NOT_FOUND} if not found in the list.
     */
    public int getPresetIndex(CommandPreset targetPreset) {
        List<CommandPreset> prsetsInList = getListView().getItems();
        for (int i = 0; i < prsetsInList.size(); i++) {
            if(prsetsInList.get(i).getDescription().equals(targetPreset.getDescription())){
                return i;
            }
        }
        return NOT_FOUND;
    }



    public PresetCardHandle getPresetCardHandle(int index) {
        return getPresetCardHandle(new CommandPreset(getListView().getItems().get(index)));
    }

    public PresetCardHandle getPresetCardHandle(CommandPreset preset) {
        Set<Node> nodes = getAllCardNodes();
        Optional<Node> presetCardNode = nodes.stream()
                .filter(n -> new PresetCardHandle(guiRobot, primaryStage, n).isSamePreset(preset))
                .findFirst();
        if (presetCardNode.isPresent()) {
            return new PresetCardHandle(guiRobot, primaryStage, presetCardNode.get());
        } else {
            return null;
        }
    }

    
    protected Set<Node> getAllCardNodes() {
        return guiRobot.lookup(CARD_PANE_ID).queryAll();
    }

    public int getNumberOfPresets() {
        return getListView().getItems().size();
    }
}
```
###### \java\guitests\UndoRedoCommandTest.java
``` java
package guitests;

import static org.junit.Assert.*;

import org.junit.Test;

import guitests.guihandles.TaskCardHandle;
import seedu.address.commons.core.Messages;
import seedu.address.logic.commands.AddCommand;
import seedu.address.model.StatesManager;
import seedu.address.testutil.TestTask;
import seedu.address.testutil.TestUtil;

public class UndoRedoCommandTest extends TaskBookGuiTest {

    @Test
    public void addUndoRedo() {
        //add one task
        TestTask[] initialList = td.getTypicalTasks();
        TestTask taskToAdd = td.nieceBirthdayMeal;
        TestTask[] finalList = TestUtil.addTasksToList(initialList, taskToAdd);
        assertUndoRedo(initialList, finalList, new String[] {taskToAdd.getAddCommand()});
    }

    @Test
    public void addUndoRedoMultiple() {
        //add one task
        TestTask[] initialList = td.getTypicalTasks();
        TestTask taskToAdd = td.nieceBirthdayMeal;
        TestTask taskToAdd2 = td.cuttingHair;
        TestTask taskToAdd3 = td.lectureToAttend;
        TestTask[] finalList = TestUtil.addTasksToList(initialList, taskToAdd, taskToAdd2, taskToAdd3);
        assertUndoRedo(initialList, finalList, 
                new String[] {taskToAdd.getAddCommand(), taskToAdd2.getAddCommand(), taskToAdd3.getAddCommand()});
    }
    
    @Test
    public void clearUndoRedo() {
        //add one task
        TestTask[] initialList = td.getTypicalTasks();
        TestTask[] finalList = {};
        assertUndoRedo(initialList, finalList, new String[] {"clear"});
    }
    
    @Test
    public void noUndo() {
        commandBox.runCommand("undo");
        assertResultMessage(StatesManager.MESSAGE_NO_PREV_STATE);
    }

    @Test
    public void noRedo() {
        commandBox.runCommand("redo");
        assertResultMessage(StatesManager.MESSAGE_NO_NEXT_STATE);
    }
    
    @Test
    public void nonStateCommands() {
        commandBox.runCommand("select 1");
        commandBox.runCommand("find lunch");
        commandBox.runCommand("list");
        commandBox.runCommand("undo");
        assertResultMessage(StatesManager.MESSAGE_NO_PREV_STATE);
    }
    
    private void assertUndoRedo(TestTask[] initialList, TestTask[] finalList, String... commands) {
        assertTrue(taskListPanel.isListMatching(initialList));
        for(int i = 0; i < commands.length; i++){
            commandBox.runCommand(commands[i]);
        }
        assertTrue(taskListPanel.isListMatching(finalList));
        for(int i = 0; i < commands.length; i++){
            commandBox.runCommand("undo");
        }
        assertTrue(taskListPanel.isListMatching(initialList));
        for(int i = 0; i < commands.length; i++){
            commandBox.runCommand("redo");
        }
        assertTrue(taskListPanel.isListMatching(finalList));
    }

}
```
###### \java\seedu\address\logic\parser\CommandParserTest.java
``` java
package seedu.address.logic.parser;

import static org.junit.Assert.*;

import java.util.ArrayList;

import org.junit.Test;

import seedu.address.commons.exceptions.IllegalValueException;

public class CommandParserTest {

    @Test
    public void nullCommand() {
        ParsedCommand command = new CommandParser(null);
        assertNoParams(command);
        assert(!command.hasValue());
    }
    
    @Test
    public void noExtraArgsCommand() {
        ParsedCommand command = new CommandParser("");
        assertNoParams(command);
        assert(!command.hasValue());
    }
    
    @Test
    public void oneValue() {
        ParsedCommand command = new CommandParser("value");
        assertNoParams(command);
        assert(command.hasValue());
        assertValue(command, 0, "value");
    }
    
    @Test
    public void multipleValues() {
        ParsedCommand command = new CommandParser("value1 value2 value3");
        assertValue(command, 0, "value1");
        assertValue(command, 1, "value2");
        assertValue(command, 2, "value3");
    }
    
    @Test
    public void noValuesAsString() {
        ParsedCommand command = new CommandParser("");
        assertEquals(command.getValuesAsString(), "");
    }
    
    @Test
    public void oneValueAsString() {
        ParsedCommand command = new CommandParser("value1");
        assertEquals(command.getValuesAsString(), "value1");
    }
    
    @Test
    public void multipleValuesAsString() {
        ParsedCommand command = new CommandParser("value1 value2 value3");
        assertEquals(command.getValuesAsString(), "value1 value2 value3");
    }
    
    @Test
    public void valueOutOfRange() {
        ParsedCommand command = new CommandParser("value1 value2 value3");
        int outOfBoundsIndex = 3;
        String errMsg = String.format(CommandParser.VALUE_OUT_OF_BOUNDS_MESSAGE, outOfBoundsIndex);
        try {
            command.getValue(outOfBoundsIndex);
            fail("Expected " + errMsg);
        } catch (IllegalValueException e) {
            assertEquals(e.getMessage(), errMsg);
        }
    }
    
    
    @Test
    public void oneParamNoValue() {
        ParsedCommand command = new CommandParser("param/");
        assert(!command.hasValue());
        assertParam(command, "param", "");
    }
    
    @Test
    public void oneParamNoName() {
        ParsedCommand command = new CommandParser("/paramValue");
        assertParam(command, "", "paramValue");
    }
    
    @Test
    public void oneParam() {
        ParsedCommand command = new CommandParser("param/paramValue");
        assertParam(command, "param", "paramValue");
    }

    @Test
    public void emptyParam() {
        ParsedCommand command = new CommandParser("/");
        assertParam(command, "", "");
    }
    
    @Test
    public void spacedParam() {
        ParsedCommand command = new CommandParser("param/param value");
        assertParam(command, "param", "param value");
    }

    @Test
    public void multipleParamDelimiters() {
        ParsedCommand command = new CommandParser("param/param/value");
        assertParam(command, "param", "param/value");
    }
    
    @Test
    public void leadingSpaceParam() {
        ParsedCommand command = new CommandParser("param/ value");
        assertParam(command, "param", " value");
    }
    
    @Test
    public void sameParams() {
        ParsedCommand command = new CommandParser("param1/paramValue1 param1/paramValue2");
        assertParam(command, "param1", "paramValue1");
        assertParamList(command, "param1", "paramValue1", "paramValue2");
    }
    
    @Test
    public void emptySameParams() {
        ParsedCommand command = new CommandParser("param1/paramValue1 param1/paramValue2");
        assertParamList(command, "param2");
    }
    
    @Test
    public void mixedSameParams() {
        ParsedCommand command = new CommandParser("param1/paramValue1 param2/paramValue1 param1/paramValue2 param2/paramValue2");
        assertParamList(command, "param1", "paramValue1", "paramValue2");
        assertParamList(command, "param2", "paramValue1", "paramValue2");
    }
    
    @Test
    public void multipleParams() {
        ParsedCommand command = new CommandParser("param1/paramValue1 param2/paramValue2");
        assertParam(command, "param1", "paramValue1");
        assertParam(command, "param2", "paramValue2");
    }

    @Test
    public void multipleSpacedParams() {
        ParsedCommand command = new CommandParser("param1/param Value 1 param2/param Value 2");
        assertParam(command, "param1", "param Value 1");
        assertParam(command, "param2", "param Value 2");
    }
    
    @Test
    public void invalidParam() {
        ParsedCommand command = new CommandParser("param1/paramValue1 param2/paramValue2");
        String invalidParam = "param3";
        String errMsg = String.format(CommandParser.NO_PARAM_MESSAGE, invalidParam);
        try {
            command.getParam(invalidParam);
            fail("Expected " + errMsg);
        } catch (IllegalValueException e) {
            assertEquals(e.getMessage(), errMsg);
        }
    }
    
    @Test
    public void getDefaultParam() {
        ParsedCommand command = new CommandParser("param1/paramValue1 param2/paramValue2");
        assertEquals(command.getParamOrDefault("param3", "-1"), "-1");
    }

    @Test
    public void ignoreDefaultParam() {
        ParsedCommand command = new CommandParser("param1/paramValue1 param2/paramValue2");
        assertEquals(command.getParamOrDefault("param2", "-1"), "paramValue2");
    }
    
    @Test
    public void valueAndParam() {
        ParsedCommand command = new CommandParser("value param/paramValue");
        assertValue(command, 0, "value");
        assertParam(command, "param", "paramValue");
    }

    @Test
    public void multipleValuesAndParams() {
        ParsedCommand command = new CommandParser("value1 value2 param1/param Value 1 param2/param Value 2");
        assertValue(command, 0, "value1");
        assertValue(command, 0, "value1");
        assertValue(command, 1, "value2");
        assertParam(command, "param1", "param Value 1");
        assertParam(command, "param2", "param Value 2");
    }
    
    @Test
    public void getAllParams() {
        ParsedCommand command = new CommandParser("param1/paramValue1 param2/paramValue1 param1/paramValue2 param2/paramValue1");
        String[] result = {"param1", "param2"};
        ArrayList<String> paramList = command.getParamList();
        assertEqualValues(paramList, result);
    }

    @Test
    public void getAllValues() {
        ParsedCommand command = new CommandParser("value1 value2 value3");
        String[] result = {"value1", "value2", "value3"};
        ArrayList<String> valueList = command.getAllValues();
        assertEqualValues(valueList, result);
    } 

    @Test
    public void hasParams() {
        ParsedCommand command = new CommandParser("param1/paramValue1 param2/paramValue1");
        String[] params = {"param1", "param2"};
        assert(command.hasParams(params));
        String[] params2 = {"param1", "param2", "param3"};
        assert(!command.hasParams(params2));
    } 
    
    private void assertValue(ParsedCommand command, int index, String value){
        try {
            assertEquals(command.getValue(index), value);
        } catch (IllegalValueException e) {
            fail(e.getMessage());
        }
    }
    
    private void assertParam(ParsedCommand command, String param, String paramValue){
        try {
            assertEquals(command.getParam(param), paramValue);
        } catch (IllegalValueException e) {
            fail(e.getMessage());
        }
    }
    
    private void assertParamList(ParsedCommand command, String param, String... paramValues){
        ArrayList<String> paramList = command.getAllParams(param);
        assertEqualValues(paramList, paramValues);
    }

    private void assertEqualValues(ArrayList<String> paramList, String[] paramValues){
        for(int i = 0; i < paramValues.length; i++){
            assertEquals(paramValues[i], paramList.get(i));
        }
    }

    private void assertNoParams(ParsedCommand command){
        assert(command.getParamList().size() == 0);
    }
}
```
###### \java\seedu\address\model\task\DateParserTest.java
``` java
package seedu.address.model.task;

import static org.junit.Assert.*;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

import org.junit.Test;

import seedu.address.commons.exceptions.IllegalValueException;

public class DateParserTest {

    public static final DateTimeFormatter DATE_DISPLAY_FORMATTER = DateTimeFormatter.ofPattern("dd-MM-yyyy HH:mm");
    
    @Test
    public void checkSimpleDates() {
        LocalDateTime datetime = parseDate("01-01-2015 15:00");
        try {
            assertEquals(datetime, DateParser.parseDate("01-01-2015 15:00"));
            assertEquals(datetime, DateParser.parseDate("01/01/2015 1500"));
            assertEquals(datetime, DateParser.parseDate("15:00 01-01-2015"));
            assertEquals(datetime, DateParser.parseDate("01-01-2015 3pm"));
            assertEquals(datetime, DateParser.parseDate("3pm 01-01-2015"));
            assertEquals(datetime, DateParser.parseDate("1st Jan 2015 3pm"));
            assertEquals(datetime, DateParser.parseDate("1st January 2015 3pm"));
        } catch (IllegalValueException e) {
            fail("Cannot parse date");
        }
    }
    
    @Test
    public void editTime() {
        LocalDateTime datetime = parseDate("01-01-2015 15:00");
        LocalDateTime newDatetime = parseDate("01-01-2015 17:00");
        try {
            assertEquals(newDatetime, DateParser.editDate("5 pm", datetime));
            assertEquals(newDatetime, DateParser.editDate("17:00", datetime));
        } catch (IllegalValueException e) {
            fail("Cannot parse date");
        }
    }
    
    @Test
    public void editDate() {
        LocalDateTime datetime = parseDate("01-01-2015 15:00");
        LocalDateTime newDatetime = parseDate("03-03-2015 15:00");
        try {
            assertEquals(newDatetime, DateParser.editDate("03-03-2015", datetime));
            assertEquals(newDatetime, DateParser.editDate("3rd Mar 2015", datetime));
        } catch (IllegalValueException e) {
            fail("Cannot parse date");
        }
    }
    
    @Test
    public void editDateTime() {
        LocalDateTime datetime = parseDate("01-01-2015 15:00");
        LocalDateTime newDatetime = parseDate("03-03-2015 17:00");
        try {
            assertEquals(newDatetime, DateParser.editDate("03-03-2015 17:00", datetime));
            assertEquals(newDatetime, DateParser.editDate("3rd Mar 2015 5pm", datetime));
        } catch (IllegalValueException e) {
            fail("Cannot parse date");
        }
    }

    @Test
    public void timeNotSpecified() {
        LocalDateTime datetime = parseDate("01-01-2015 00:00");
        try {
            assertEquals(datetime, DateParser.parseDate("01-01-2015"));
            assertEquals(datetime, DateParser.parseDate("1st Jan 2015"));
        } catch (IllegalValueException e) {
            fail("Cannot parse date");
        }
    }
    
    private LocalDateTime parseDate(String date){
        return LocalDateTime.parse(date, DATE_DISPLAY_FORMATTER);
    }
}
```
###### \java\seedu\address\model\task\TimeIntervalTest.java
``` java
package seedu.address.model.task;

import static org.junit.Assert.*;

import org.junit.Test;

import seedu.address.commons.exceptions.IllegalValueException;

public class TimeIntervalTest {

    @Test
    public void checkValidIntervals() {
        try {
            TimeInterval t;
            t = new TimeInterval("10m");
            assertEquals(t.getAsMinutes(), 10);
            t = new TimeInterval("4h");
            assertEquals(t.getAsMinutes(), 4 * 60);
            t = new TimeInterval("40h");
            assertEquals(t.getAsMinutes(), 40 * 60);
            t = new TimeInterval("2d");
            assertEquals(t.getAsMinutes(), 2 * 24 * 60);
            t = new TimeInterval("3w");
            assertEquals(t.getAsMinutes(), 3 * 7 * 24 * 60);
```
###### \java\seedu\address\model\task\TimeIntervalTest.java
``` java
        } catch (IllegalValueException e) {
            fail("Could not parse time interval");
        }
    }
    
    @Test
    public void checkInvalidIntervals() {
        checkInvalidInterval("1");
        checkInvalidInterval("1 h");
        checkInvalidInterval("0.5h");
    }
    
    private void checkInvalidInterval(String invalidInterval){
        try {
            TimeInterval t;
            t = new TimeInterval(invalidInterval);
            fail("Successfully parsed wrong interval");
        } catch (IllegalValueException e) {
        }
    }
    
}
```
###### \java\seedu\address\TestApp.java
``` java
    public String getSaveFilePath(){
        return config.getTaskBookFilePath();
    }
```
###### \java\seedu\address\testutil\TestPreset.java
``` java
package seedu.address.testutil;

import seedu.address.model.CommandPreset;

public class TestPreset extends CommandPreset{

    public TestPreset(String command, String description){
        super(command, description);
    }
}
```
###### \java\seedu\address\testutil\TestUtil.java
``` java
    public static boolean compareCardAndPreset(PresetCardHandle card, CommandPreset preset) {
        return card.isSamePreset(preset);
    }
```
