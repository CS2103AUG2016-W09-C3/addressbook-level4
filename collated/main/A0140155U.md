# A0140155U
###### \java\seedu\address\commons\events\model\FilePathChangedEvent.java
``` java
package seedu.address.commons.events.model;

import seedu.address.commons.events.BaseEvent;

/** Indicates the filepath of the AddressBook has changed*/
public class FilePathChangedEvent extends BaseEvent {

    public final String filePath;

    public FilePathChangedEvent (String filePath){
        this.filePath = filePath;
    }

    @Override
    public String toString() {
        return "new file path: " + filePath;
    }
}
```
###### \java\seedu\address\commons\exceptions\StateException.java
``` java
package seedu.address.commons.exceptions;

/**
 * Signals that a state could not be loaded.
 */
public class StateException extends Exception {
    /**
     * @param message should contain relevant information on why the state failed to load
     */
    public StateException(String message) {
        super(message);
    }
}
```
###### \java\seedu\address\logic\commands\Command.java
``` java
    public static final String[] REQUIRED_PARAMS = {};
    public static final String[] POSSIBLE_PARAMS = {".*"};
    
    /**
     * Returns true if the command creates a new state of the model.
     * The command creates a new state if the command has the potential to modify the model data (e.g. add, delete)
     * Commands that do not modify data return false (e.g. list, help).
     * The only exceptions are the "undo" and "redo" command, which modify data but do not create new states.
     * 
     * @return whether or not the command creates a new state
     */

    public abstract boolean createsNewState();
```
###### \java\seedu\address\logic\commands\DoneCommand.java
``` java
package seedu.address.logic.commands;

import seedu.address.commons.core.Messages;
import seedu.address.commons.core.UnmodifiableObservableList;
import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.model.tag.Tag;
import seedu.address.model.tag.UniqueTagList;
import seedu.address.model.task.*;
import seedu.address.model.task.UniqueTaskList.DuplicateTaskException;
import seedu.address.model.task.UniqueTaskList.TaskNotFoundException;

import java.util.HashSet;
import java.util.Set;

/**
 * Marks a task in the task list as done.
 */
public class DoneCommand extends Command {

    public static final String COMMAND_WORD = "done";

    public static final String[] REQUIRED_PARAMS = {};
    public static final String[] POSSIBLE_PARAMS = {};
    
    
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Marks a task as done.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_SUCCESS = "Task marked as %1$s: %2$s";
    public static final String MESSAGE_EXCEPTION = "Error executing command.";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the address book";
    public static final String MESSAGE_ALREADY_DONE_TASK = "Task is already done.";

    private final int targetIndex;

    /**
     * Convenience constructor using raw values for adding 
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public DoneCommand(int targetIndex) throws IllegalValueException {
        this.targetIndex = targetIndex;
    }

    @Override
    public CommandResult execute() {
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToDelete = lastShownList.get(targetIndex - 1);
        if(taskToDelete.getDoneFlag().isDone()){
            return new CommandResult(MESSAGE_ALREADY_DONE_TASK);
        }
        Task toAdd = null;
        try {
            DoneFlag newFlag = new DoneFlag(DoneFlag.DONE);
            if(!taskToDelete.isDated()){
                toAdd = new Task(taskToDelete.getName(), taskToDelete.getPriority(), taskToDelete.getInformation(), 
                            newFlag, taskToDelete.getTags());
            }else{
                ReadOnlyDatedTask datedTaskToDelete = (ReadOnlyDatedTask) taskToDelete;
                toAdd = new DatedTask(datedTaskToDelete.getName(), datedTaskToDelete.getDateTime(),
                        datedTaskToDelete.getLength(), datedTaskToDelete.getRecurrance(),
                        datedTaskToDelete.getPriority(), datedTaskToDelete.getInformation(), 
                        newFlag, datedTaskToDelete.getTags());
            }
            model.deleteTask(taskToDelete);
            model.addTaskToIndex(toAdd, targetIndex - 1);
            //model.addTask(toAdd);
        } catch (DuplicateTaskException e) {
            assert false : "Can't add a duplicate task.";
            return new CommandResult(MESSAGE_EXCEPTION);
        } catch (IllegalValueException e) {
            // Should never happen
            assert false : "DoneFlag class is corrupt. Call a programmer.";
            return new CommandResult(MESSAGE_EXCEPTION);
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be missing";
            return new CommandResult(MESSAGE_EXCEPTION);
        } 
        
        return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd.getDoneFlag().toString(), toAdd.getName()));

    }


    @Override
    public boolean createsNewState() {
        return true;
    }
}
```
###### \java\seedu\address\logic\commands\FilepathCommand.java
``` java
package seedu.address.logic.commands;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import seedu.address.commons.exceptions.IllegalValueException;
/**
 * Changes the filepath of the address book.
 */
public class FilepathCommand extends Command {

    public static final String COMMAND_WORD = "filepath";

    public static final String[] REQUIRED_PARAMS = {};
    public static final String[] POSSIBLE_PARAMS = {};
    
    public static final Pattern FILEPATH_REGEX = Pattern.compile(
            "^([a-zA-Z]\\:\\\\)?[^\\\\:\\*\\|\\\"<>\\?\\n]+(\\\\[^\\\\:\\*\\|\\\"<>\\?\\n]+)*\\.xml$");
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Changes the filepath. "
            + "Parameter: FILEPATH"
            + "Parameter should be a valid file name, ending in .xml."
            + "Examples: addressbook.xml, data\\addressbook.xml, C:\\data\\addressbook.xml";

    public static final String MESSAGE_SUCCESS = "File path changed to %1$s";
    public static final String MESSAGE_INVALID_PATH = "Invalid file path. Parameter should be a valid file name, ending in .xml.\n" + 
                                                    "Examples: addressbook.xml, data\\addressbook.xml, C:\\data\\addressbook.xml";

    private final String filePath;

    public FilepathCommand(String filePath){
        this.filePath = filePath;
    }

    @Override
    public CommandResult execute() {
        assert model != null;
        assert filePath != null;
        final Matcher matcher = FILEPATH_REGEX.matcher(filePath);
        if (!matcher.matches()) {
            return new CommandResult(MESSAGE_INVALID_PATH);
        }
        model.changeFilePath(filePath);
        return new CommandResult(String.format(MESSAGE_SUCCESS, filePath));

    }

    @Override
    public boolean createsNewState() {
        return true;
    }

}
```
###### \java\seedu\address\logic\commands\RedoCommand.java
``` java
package seedu.address.logic.commands;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.commons.exceptions.StateException;

/**
 * Adds a tasks to the address book.
 */
public class RedoCommand extends Command {

    public static final String COMMAND_WORD = "redo";

    public static final String[] REQUIRED_PARAMS = {};
    public static final String[] POSSIBLE_PARAMS = {""};
    
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Redoes a command that was undone. ";
    public static final String MESSAGE_SUCCESS = "Redid previous command \"%1$s\"";

    public RedoCommand(){
    }

    @Override
    public CommandResult execute() {
        assert model != null;
        try {
            String commandString = model.loadNextState();
            return new CommandResult(String.format(MESSAGE_SUCCESS, commandString));
        } catch (StateException e) {
            return new CommandResult(e.getMessage());
        }

    }

    @Override
    public boolean createsNewState() {
        return false; 
    }
}
```
###### \java\seedu\address\logic\commands\UndoCommand.java
``` java
package seedu.address.logic.commands;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.commons.exceptions.StateException;

/**
 * Adds a tasks to the address book.
 */
public class UndoCommand extends Command {

    public static final String COMMAND_WORD = "undo";

    public static final String[] REQUIRED_PARAMS = {};
    public static final String[] POSSIBLE_PARAMS = {""};
    
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Undoes the previous command. ";
    public static final String MESSAGE_SUCCESS = "Undid previous command \"%1$s\"";

    public UndoCommand(){
    }

    @Override
    public CommandResult execute() {
        assert model != null;
        try {
            String commandString = model.loadPreviousState();
            return new CommandResult(String.format(MESSAGE_SUCCESS, commandString));
        } catch (StateException e) {
            return new CommandResult(e.getMessage());
        }

    }

    @Override
    public boolean createsNewState() {
        return false; 
    }
}
```
###### \java\seedu\address\logic\commands\UndoneCommand.java
``` java
package seedu.address.logic.commands;

import seedu.address.commons.core.Messages;
import seedu.address.commons.core.UnmodifiableObservableList;
import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.model.tag.Tag;
import seedu.address.model.tag.UniqueTagList;
import seedu.address.model.task.*;
import seedu.address.model.task.UniqueTaskList.DuplicateTaskException;
import seedu.address.model.task.UniqueTaskList.TaskNotFoundException;

import java.util.HashSet;
import java.util.Set;

/**
 * Marks a task in the task list as undone.
 */
public class UndoneCommand extends Command {

    public static final String COMMAND_WORD = "undone";

    public static final String[] REQUIRED_PARAMS = {};
    public static final String[] POSSIBLE_PARAMS = {};
    
    
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Marks a task as undone.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_SUCCESS = "Task marked as %1$s: %2$s";
    public static final String MESSAGE_EXCEPTION = "Error executing command.";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the address book";
    public static final String MESSAGE_ALREADY_UNDONE_TASK = "Task is already undone.";

    private final int targetIndex;

    /**
     * Convenience constructor using raw values for adding 
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public UndoneCommand(int targetIndex) throws IllegalValueException {
        this.targetIndex = targetIndex;
    }

    @Override
    public CommandResult execute() {
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToDelete = lastShownList.get(targetIndex - 1);
        if(!taskToDelete.getDoneFlag().isDone()){
            return new CommandResult(MESSAGE_ALREADY_UNDONE_TASK);
        }
        
        Task toAdd = null;
        try {
            DoneFlag newFlag = new DoneFlag(DoneFlag.NOT_DONE);
            if(!taskToDelete.isDated()){
                toAdd = new Task(taskToDelete.getName(), taskToDelete.getPriority(), taskToDelete.getInformation(), 
                            newFlag, taskToDelete.getTags());
            }else{
                ReadOnlyDatedTask datedTaskToDelete = (ReadOnlyDatedTask) taskToDelete;
                toAdd = new DatedTask(datedTaskToDelete.getName(), datedTaskToDelete.getDateTime(),
                        datedTaskToDelete.getLength(), datedTaskToDelete.getRecurrance(),
                        datedTaskToDelete.getPriority(), datedTaskToDelete.getInformation(), 
                        newFlag, datedTaskToDelete.getTags());
            }
            model.deleteTask(taskToDelete);
            model.addTaskToIndex(toAdd, targetIndex - 1);
        } catch (DuplicateTaskException e) {
            assert false : "Can't add a duplicate task.";
            return new CommandResult(MESSAGE_EXCEPTION);
        } catch (IllegalValueException e) {
            // Should never happen
            assert false : "DoneFlag class is corrupt. Call a programmer.";
            return new CommandResult(MESSAGE_EXCEPTION);
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be missing";
            return new CommandResult(MESSAGE_EXCEPTION);
        } 
        
        return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd.getDoneFlag().toString(), toAdd.getName()));

    }

    @Override
    public boolean createsNewState() {
        return true;
    }
}
```
###### \java\seedu\address\logic\LogicManager.java
``` java
        CommandResult cr = command.execute();
        if(command.createsNewState()){
            model.saveState(commandText);
        }
        return cr;
```
###### \java\seedu\address\logic\parser\CommandParser.java
``` java
package seedu.address.logic.parser;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;

import seedu.address.commons.exceptions.IllegalValueException;

/**
 * Parses a command into values and parameters.
 */
public class CommandParser implements ParsedCommand{
    
    private static final String COMMAND_DELIMITER = " ";
    private static final String PARAM_DELIMITER = "/";
    public static final String VALUE_OUT_OF_BOUNDS_MESSAGE = "Value index out of bounds: %1$s";
    public static final String NO_PARAM_MESSAGE = "Could not find param: %1$s";
    
    /*
     * A command consists of values, followed by parameters.
     * A value is a string that does not contain a /.
     * A parameter consists of a param name and a param value, seperated by a / e.g name/value.
     * 
     * A param can have multiple values, when multiple params have the same name, all values
     * are group in one param.
     */
    
    // List of values
    private ArrayList<String> values = new ArrayList<>();
    // Param name -> list of param values
    private HashMap<String, ArrayList<String>> params = new HashMap<>();
    
    public CommandParser(String command){
        loadFromString(command);
    }
    
    /**
     * Loads values and params from string.
     */
    private void loadFromString(String command){
        if(command == null || command.isEmpty()){
            return;
        }
        String[] splitted = command.split(COMMAND_DELIMITER);
        
        int index = 0;
        // Find all values
        index = loadValues(splitted, index);
        // Find all params
        loadParams(splitted, index);
        
    }

    /**
     * Loads values from command.
     * Returns the index of the first param in the command.
     */
    private int loadValues(String[] splitted, int index) {
        // Load string tokens until we encounter a param token
        while(index < splitted.length && !isParamToken(splitted[index])){
            values.add(splitted[index]);
            index++;
        }
        return index;
    }

    /**
     * Loads params from command.
     */
    private void loadParams(String[] splitted, int index) {
        // This stores the param name
        String currentParam = null;
        // This stores the param value
        StringBuilder currentParamValue = new StringBuilder();
        for(int i = index; i < splitted.length; i++){
            String token = splitted[i];
            if(isParamToken(token)){
                // New param, flush the param value, add the old param and start over
                addParam(currentParam, currentParamValue.toString());
                
                int paramDelimIndex = token.indexOf(PARAM_DELIMITER);
                currentParam = token.substring(0, paramDelimIndex).toLowerCase();
                currentParamValue = new StringBuilder();
                currentParamValue.append(token.substring(paramDelimIndex + 1, token.length()));
            }else{
                // Not a param, add the token on to the value
                currentParamValue.append(COMMAND_DELIMITER);
                currentParamValue.append(token);
            }
        }
        addParam(currentParam, currentParamValue.toString());
    }


    /**
     * Adds a param to the param list.
     */
    private void addParam(String currentParam, String currentParamValue) {
        if(currentParam != null){
            if(!params.containsKey(currentParam)){
                // If list doesn't exist, create one
                params.put(currentParam, new ArrayList<>());
            }
            params.get(currentParam).add(currentParamValue);
        }
    }
    
    /**
     * Checks if a string token is a param.
     */
    private boolean isParamToken(String token){
        return token.contains(PARAM_DELIMITER);
    }

    /**
     * Retrieves the first param from the list corresponding to the param name.
     * Throws an error if the param name has no values.
     */
    @Override
    public String getParam(String paramName) throws IllegalValueException {
        if(!params.containsKey(paramName) || params.get(paramName).size() == 0){
            throw new IllegalValueException(String.format(NO_PARAM_MESSAGE, paramName));
        }
        return params.get(paramName).get(0);
    }
    
    /**
     * Retrieves the first param from the list corresponding to the param name.
     * If the param name has no values, return the default value.
     */
    @Override
    public String getParamOrDefault(String paramName, String defaultParam)  {
        if(!params.containsKey(paramName) || params.get(paramName).size() == 0){
            return defaultParam;
        }
        return params.get(paramName).get(0);
    }
    
    /**
     * Retrieves a list of params corresponding to the param name.
     * If the param name has no values, returns an empty list.
     */
    @Override
    public ArrayList<String> getAllParams(String paramName) {
        if(!params.containsKey(paramName) || params.get(paramName).size() == 0){
            return new ArrayList<String>();
        }
        ArrayList<String> readOnlyParamData = new ArrayList<> (params.get(paramName));
        return readOnlyParamData;
    }
    
    /**
     * Retrieves the very first value in the list.
     * Use when you expect only one value in the command.
     */
    @Override
    public String getValue() throws IllegalValueException {
        return getValue(0);
    }
    
    /**
     * Retrieves the nth value in the list.
     */
    @Override
    public String getValue(int index) throws IllegalValueException {
        if(index >= values.size()){
            throw new IllegalValueException(String.format(VALUE_OUT_OF_BOUNDS_MESSAGE, index));
        }
        return values.get(index);
    }

    /**
     * Get all values.
     */
    @Override
    public ArrayList<String> getAllValues(){
        ArrayList<String> readOnlyValues = new ArrayList<> (values);
        return readOnlyValues;
    }
    

    /**
     * Get all params.
     */
    @Override
    public ArrayList<String> getParamList(){
        ArrayList<String> readOnlyParams = new ArrayList<> (params.keySet());
        return readOnlyParams;
    }

    /**
     * Retrieves list of values joined with spaces.
     */
    @Override
    public String getValuesAsString() {
        return String.join(" ", values);
    }

    /**
     * Check if command contains all the params in the array.
     * Useful for checking if the command is valid.
     */
    @Override
    public boolean hasParams(String[] requiredParams) {
        for(String param : requiredParams){
            if(!params.containsKey(param)){
                return false;
            }
        }
        return true;
    }

    /**
     * Check if command has at least one value.
     * Useful for checking if the command is valid.
     */
    @Override
    public boolean hasValue() {
        return values.size() > 0;
    }
    
    /**
     * Check if command has value at the particular index
     * Useful for checking if the command is valid.
     */
    @Override
    public boolean hasValueAtIndex(int index){
    	return values.size() > index;
    }
    
    @Override
    public boolean hasUnnecessaryParams(String[] possibleParams) {
        for(String param : params.keySet()){
            if(!matchingParam(param.toLowerCase(), possibleParams)){
                return true;
            }
        }
        return false;
    }
    
    private boolean matchingParam(String param, String[] possibleParams){
        for(String possibleParam : possibleParams){
            if(param.toLowerCase().matches(possibleParam)){
                return true;
            }
        }
        return false;
    }
}
```
###### \java\seedu\address\logic\parser\ParsedCommand.java
``` java
package seedu.address.logic.parser;

import java.util.ArrayList;
import java.util.Iterator;

import seedu.address.commons.exceptions.IllegalValueException;

/*
 * Interface for a parsed command
 */
public interface ParsedCommand {
    
    /**
     * Retrieves the first param from the list corresponding to the param name.
     * Throws an error if the param name has no values.
     */
    String getParam(String paramName) throws IllegalValueException;

    /**
     * Retrieves the first param from the list corresponding to the param name.
     * If the param name has no values, return the default value.
     */
    String getParamOrDefault(String paramName, String defaultParam);

    /**
     * Retrieves a list of params corresponding to the param name.
     * If the param name has no values, returns an empty list.
     */
    ArrayList<String> getParamList();
    
    /**
     * Retrieves the very first value in the list.
     * Use when you expect only one value in the command.
     */
    String getValue() throws IllegalValueException;

    /**
     * Retrieves the nth value in the list.
     */
    String getValue(int index) throws IllegalValueException;

    /**
     * Get all values.
     */
    ArrayList<String> getAllValues();

    /**
     * Get all params.
     */
    ArrayList<String> getAllParams(String paramName);

    /**
     * Retrieves list of values joined with spaces.
     */
    String getValuesAsString();


    /**
     * Check if command contains all the params in the array.
     * Useful for checking if the command is valid.
     */
    boolean hasParams(String[] params);

    /**
     * Check if command has at least one value.
     * Useful for checking if the command is valid.
     */
    boolean hasValue();
    
    /**
     * Check if command has value at the particular index
     * Useful for checking if the command is valid.
     */
    boolean hasValueAtIndex(int index);
    
    /**
     * Check if command has value at the particular index
     * Useful for checking if the command is valid.
     */
    boolean hasUnnecessaryParams(String[] possibleParams);
    
}
```
###### \java\seedu\address\logic\parser\Parser.java
``` java
    /**
     * Parses arguments in the context of the done task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareDone(ParsedCommand command) {
        try{
            Optional<Integer> index = parseIndex(command.getValue());
            if(!index.isPresent()){
                return new IncorrectCommand(
                        String.format(MESSAGE_INVALID_COMMAND_FORMAT, SelectCommand.MESSAGE_USAGE));
            }

            return new DoneCommand(index.get());
        }catch(IllegalValueException ex){
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, SelectCommand.MESSAGE_USAGE));
        }
    }
    
    /**
     * Parses arguments in the context of the undone task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareUndone(ParsedCommand command) {
        try{
            Optional<Integer> index = parseIndex(command.getValue());
            if(!index.isPresent()){
                return new IncorrectCommand(
                        String.format(MESSAGE_INVALID_COMMAND_FORMAT, SelectCommand.MESSAGE_USAGE));
            }

            return new UndoneCommand(index.get());
        }catch(IllegalValueException ex){
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, SelectCommand.MESSAGE_USAGE));
        }
    }
```
###### \java\seedu\address\MainApp.java
``` java
    @Subscribe
    public void handleFilePathChangedEvent(FilePathChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event, "Config data changed, saving to file"));
        String oldFilePath = config.getAddressBookFilePath();
        try {
            storage.setAddressBookFilePath(event.filePath);
            storage.saveAddressBook(model.getAddressBook());
            config.setAddressBookFilePath(event.filePath);
            ConfigUtil.saveConfig(config, config.getConfigFilePath());
        } catch (IOException e) {
            storage.setAddressBookFilePath(oldFilePath);
            config.setAddressBookFilePath(oldFilePath);
            logger.warning("Failed to save config file, reverting to old : " + StringUtil.getDetails(e));
        }
    }
```
###### \java\seedu\address\MainApp.java
``` java
    
    public static void main(String[] args) {
        launch(args);
    }
}
```
###### \java\seedu\address\model\AddressBookState.java
``` java
/**
 * Represents a state of the address book.
 * 
 * An address book state consists of a state and a command.
 * The state stores the state of the address book at the point the command was executed.
 * The command stores the command that was executed to achieve this state.
 * 
 * Used simply as a wrapper for two variables.
 */
public class AddressBookState {
    private final AddressBook state;
    private final String command;
    public static final String INITIAL_STATE = "Initial state";
    
    public AddressBookState(AddressBook state){
        this(state, INITIAL_STATE);
    }
    
    public AddressBookState(AddressBook state, String command){
        this.state = new AddressBook(state);
        this.command = command;
    }
    
    public AddressBook getState(){
        return state;
    }
    
    public String getCommand(){
        return command;
    }
}
```
###### \java\seedu\address\model\ModelManager.java
``` java
    private final States states;
```
###### \java\seedu\address\model\ModelManager.java
``` java
        states = new StatesManager(new AddressBookState(addressBook));
```
###### \java\seedu\address\model\ModelManager.java
``` java
        states = new StatesManager(new AddressBookState(addressBook));
```
###### \java\seedu\address\model\ModelManager.java
``` java
    /** Raises an event to indicate the config has changed */
    @Override
    public void changeFilePath(String filePath) {
        raise(new FilePathChangedEvent(filePath));
    }
```
###### \java\seedu\address\model\ModelManager.java
``` java
    @Override
    public void saveState(String commandText) {
        states.saveState(new AddressBookState(addressBook, commandText));
    }

    @Override
    public String loadPreviousState() throws StateException {
        return loadState(states.loadPreviousState());
    }

    @Override
    public String loadNextState() throws StateException {
        return loadState(states.loadNextState());
    }
    
    private String loadState(AddressBookState newState) {
        addressBook.resetData(newState.getState());
        indicateAddressBookChanged();
        return newState.getCommand();
    }
```
###### \java\seedu\address\model\States.java
``` java
package seedu.address.model;

import seedu.address.commons.exceptions.StateException;

/**
 * The API of the States component.
 */
public interface States {
    /** Saves a state to the state list. */
    public void saveState(AddressBookState newState);
    
    /** Loads the previous state. */
    public AddressBookState loadPreviousState() throws StateException;

    /** Loads the next state. */
    public AddressBookState loadNextState() throws StateException;
    
}
```
###### \java\seedu\address\model\StatesManager.java
``` java
package seedu.address.model;

import java.util.ArrayList;

import seedu.address.commons.exceptions.StateException;

public class StatesManager implements States{
    /**
     * States are stored as a list, with currentState pointing to the current state of the address book in the model.
     */
    private ArrayList<AddressBookState> states = new ArrayList<>();
    private int currentState = 0;
    
    private final int MAX_STATES = 10; // Does not include initial state
    public final static String MESSAGE_NO_PREV_STATE = "No previous state to load.";
    public final static String MESSAGE_MAX_STATES_EXCEEDED = "Maximum undos exceeded.";
    public final static String MESSAGE_NO_NEXT_STATE = "No next state to load.";
    
    public StatesManager(AddressBookState initialState){
        states.add(initialState);
    }


    public void saveState(AddressBookState newState){
        // When a state is saved, all "future states" i.e. states that have been undone are overwritten.
        while(states.size() - 1 > currentState){
            states.remove(states.size() - 1);
        }
        
        states.add(newState);
        if(currentState == MAX_STATES){
            // Exceeded cap, delete the first state
            states.remove(0);
        }else{
            currentState++;
        }
    }


    public AddressBookState loadPreviousState() throws StateException{
        if(currentState == 0){
            assert !states.isEmpty();
            if(states.get(0).getCommand().equals(AddressBookState.INITIAL_STATE)){
                throw new StateException(MESSAGE_NO_PREV_STATE);
            }else{
                // First state is not the initial state.
                // This means it was deleted by saveState() due to hitting max capacity
                throw new StateException(MESSAGE_MAX_STATES_EXCEEDED);
            }
        }
        // Note: Unlike loadNextState(), return current state command, but previous state data.
        String commandString = getCurrentState().getCommand();
        currentState--;
        return new AddressBookState(getCurrentState().getState(), commandString);
    }

    public AddressBookState loadNextState() throws StateException{
        if(currentState == states.size() - 1){
            throw new StateException(MESSAGE_NO_NEXT_STATE);
        }
        // Note: Unlike loadNextState(), return current state command and data.
        currentState++;
        return getCurrentState();
    }

    private AddressBookState getCurrentState() {
        return states.get(currentState);
    }
    
}
```
###### \java\seedu\address\model\task\DateParser.java
``` java
package seedu.address.model.task;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.List;

import org.antlr.runtime.tree.Tree;

import com.joestelmach.natty.*;

import seedu.address.commons.exceptions.IllegalValueException;
/**
 * Wrapper class for Natty.
 * Parses dates from a string.
 */
public class DateParser {
    private static final String RELATIVE_DATE_STRING = "RELATIVE_DATE";
    private static final String EXPLICIT_DATE_STRING = "EXPLICIT_DATE";
    private static final String TIME_STRING = "EXPLICIT_TIME";
    
    private static Parser nattyParser = new Parser();
    
    /*
     * Parses a date time from a string using natty.
     */
    public static LocalDateTime parseDate(String dateString) throws IllegalValueException{
        return getDateTime(parseNatty(dateString));
    }
    
    /*
     * Edits a date based on a string parsed using natty.
     * Only edits the old date or time if a new date or time is provided respectively.
     * E.g.
     * dateString: 5pm => Only Time changes
     * dateString: tomorrow => Only Date changes
     * dateString: 5pm tomorrow => Both change
     */
    public static LocalDateTime editDate(String dateString, LocalDateTime oldDatetime) throws IllegalValueException {
        DateGroup dateGroup = parseNatty(dateString);
        LocalDateTime parsedDate = getDateTime(dateGroup);
        LocalDateTime newDate = oldDatetime;
        if(searchDateTree(dateGroup, RELATIVE_DATE_STRING) || searchDateTree(dateGroup, EXPLICIT_DATE_STRING)){
            newDate = newDate.withYear(parsedDate.getYear()).withDayOfYear(parsedDate.getDayOfYear());
        }
        if(searchDateTree(dateGroup, TIME_STRING)){
            newDate = newDate.withHour(parsedDate.getHour()).withMinute(parsedDate.getMinute());
        }
        return newDate;
    }
    
    /*
     * Reschedule a date based on a string rescheduleInterval parsed using TimeInterval 
     * Time interval added by to the current datetime using natty
     *
     */
    public static LocalDateTime rescheduleDate(LocalDateTime rescheduleDatetime, String rescheduleInterval) throws IllegalValueException{
    	TimeInterval timeInterval = new TimeInterval(rescheduleInterval);
        int minutes = timeInterval.getAsMinutes();
        rescheduleDatetime = rescheduleDatetime.plusMinutes(minutes);

    	return rescheduleDatetime;
    }
    
    /*
     * Searches natty's generated date tree for a string value
     * Used to check if the date string has a date or time by searching the date tree generated by natty.
     * Refer to natty documentation for the tree layout.
     */
    private static boolean searchDateTree(DateGroup dateGroup, String toSearch) {
        Tree textGroups = dateGroup.getSyntaxTree().getChild(0);
        for(int i = 0; i < textGroups.getChildCount(); i++){
            String text = textGroups.getChild(i).getText();
            if(text.equals(toSearch)){
                return true;
            }
        }
        return false;
    }
    
    /*
     * Parses a date using natty.
     */
    private static DateGroup parseNatty(String dateString) throws IllegalValueException{
        List<DateGroup> dates = nattyParser.parse(dateString);
        if(dates.isEmpty() || dates.get(0).getDates().isEmpty()){
            throw new IllegalValueException("Date not parsable.");
        }
        return dates.get(0);
    }
    
    /*
     * Converts a natty DateGroup into a LocalDateTime.
     */
    private static LocalDateTime getDateTime(DateGroup dateGroup){
        return LocalDateTime.ofInstant(dateGroup.getDates().get(0).toInstant(), ZoneId.systemDefault());
    }
    
}
```
###### \java\seedu\address\model\task\DoneFlag.java
``` java
package seedu.address.model.task;

import seedu.address.commons.exceptions.IllegalValueException;
/**
 * Represents a done status in the task book.
 * Guarantees: immutable; is valid as declared in {@link #isValidLength(String)}
 */
public class DoneFlag {
    
    public static final String DONE = "Done";
    public static final String NOT_DONE = "Not done";

    public static final String MESSAGE_FLAG_CONSTRAINTS = "Done flag should be \"" + DONE + "\" or \"" + NOT_DONE + "\".";
    
    public final String done;
    
    /**
     * Validates given done value.
     *
     * @throws IllegalValueException if given doneFlag string is invalid.
     */

    public DoneFlag(String value) throws IllegalValueException {
        assert value != null;
        value = value.trim();
        if(!isValidFlag(value)){
            
            throw new IllegalValueException(MESSAGE_FLAG_CONSTRAINTS);
        }
        done = value;
    }

    private boolean isValidFlag(String test) {
        return test.equals(DONE) || test.equals(NOT_DONE);
    }
    
    @Override
    public String toString() {
        return this.done;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof DoneFlag // instanceof handles nulls
                && this.done.equals(((DoneFlag) other).done)); // state check
    }

    @Override
    public int hashCode() {
        return done.hashCode();
    }
    
    public boolean isDone(){
        return done.equals(DONE);
    }

}
```
###### \java\seedu\address\model\task\TimeInterval.java
``` java
package seedu.address.model.task;

import java.util.HashMap;
import java.util.Objects;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import seedu.address.commons.exceptions.IllegalValueException;

public class TimeInterval {
    public static final String MESSAGE_TIME_INTERVAL_CONSTRAINTS = "Time interval should be a positive number followed by a character e.g 5h, 1d, 2m, 1w. " +
            "Acceptable time units are m/min/mins (minutes) h/hr/hrs (hours), d/day/days (days), w/week/weeks (weeks)";

    //public static final String INTERVAL_VALIDATION_REGEX = "\\d+\\c";
    private static final Pattern INTERVAL_VALIDATION_REGEX = Pattern.compile("(?<length>\\d+)(?<unit>[a-zA-Z]+)");
    private static HashMap<String, Integer> INTERVAL_TO_MINUTES = new HashMap<>();

    private static HashMap<String, String> MINUTE_ALIASES = new HashMap<>();
    
    static
    {
        INTERVAL_TO_MINUTES.put("m", 1);
        INTERVAL_TO_MINUTES.put("h", 60);
        INTERVAL_TO_MINUTES.put("d", 24 * 60);
        INTERVAL_TO_MINUTES.put("w", 7 * 24 * 60);
        MINUTE_ALIASES.put("min", "m");
        MINUTE_ALIASES.put("mins", "m");
        MINUTE_ALIASES.put("hr", "h");
        MINUTE_ALIASES.put("hrs", "h");
        MINUTE_ALIASES.put("day", "d");
        MINUTE_ALIASES.put("days", "d");
        MINUTE_ALIASES.put("week", "w");
        MINUTE_ALIASES.put("weeks", "w");
    }
    
    public final String intervalString;
    public final int length;
    public String unit;
    
    /**
     * Validates given information.
     *
     * @throws IllegalValueException if given information string is invalid.
     */
    public TimeInterval(String intervalString) throws IllegalValueException {
        assert intervalString != null;
        intervalString = intervalString.toLowerCase().trim();

        this.intervalString = intervalString;
        
        final Matcher matcher = INTERVAL_VALIDATION_REGEX.matcher(intervalString);
        if (!matcher.matches()) {
            throw new IllegalValueException(MESSAGE_TIME_INTERVAL_CONSTRAINTS);
        }
        length = Integer.parseInt(matcher.group("length"));
        unit = matcher.group("unit");
        
        if (MINUTE_ALIASES.containsKey(unit)){
            this.unit = MINUTE_ALIASES.get(unit);
        }
        
        if(!isValidInterval(length, unit)){
            throw new IllegalValueException(MESSAGE_TIME_INTERVAL_CONSTRAINTS);
        }
    }
    
    private boolean isValidInterval(int length, String unit){
        if(!INTERVAL_TO_MINUTES.containsKey(unit)){
            return false;
        }
        /*
        if(length == 0){
            return false;
        }
        */
        return true;
    }
    
    public int getAsMinutes(){
        return length * INTERVAL_TO_MINUTES.get(unit);
    }
    
    @Override
    public String toString() {
        return length + unit;
    }
    
    public String getUnit(){
    	return unit;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TimeInterval // instanceof handles nulls
                && this.length == ((TimeInterval) other).length
                && this.unit.equals(((TimeInterval) other).unit)); // state check
    }

    @Override
    public int hashCode() {
        return Objects.hash(length, unit);
    }
}
```
###### \java\seedu\address\storage\XmlAdaptedPerson.java
``` java

    /**
     * Converts a given Task into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created XmlAdaptedPerson
     */
    public XmlAdaptedPerson(ReadOnlyTask source) {
        name = source.getName().fullName;
        priority = source.getPriority().toString();
        information = source.getInformation().fullInformation;
        done = source.getDoneFlag().toString();
        tagged = new ArrayList<>();
        for (Tag tag : source.getTags()) {
            tagged.add(new XmlAdaptedTag(tag));
        }
        
        isDated = source.isDated();
        if(isDated){
            ReadOnlyDatedTask datedSource = (ReadOnlyDatedTask) source;
            dateTime = datedSource.getDateTime().toString();
            length = datedSource.getLength().toString();
            recurrance = datedSource.getRecurrance().toString();
        }
    }

    /**
     * Converts this jaxb-friendly adapted person object into the model's Task object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted person
     */
    public Task toModelType() throws IllegalValueException {
        final List<Tag> personTags = new ArrayList<>();
        for (XmlAdaptedTag tag : tagged) {
            personTags.add(tag.toModelType());
        }
        final Name name = new Name(this.name);
        final Priority priority = new Priority(this.priority);
        final Information information = new Information(this.information);
        final DoneFlag done = new DoneFlag(this.done);
        final UniqueTagList tags = new UniqueTagList(personTags);
        if(isDated){
            final DateTime dateTime = new DateTime(this.dateTime, true);
            final Length length = new Length(this.length);
            final Recurrance recurrance = new Recurrance(this.recurrance);
            return new DatedTask(name, dateTime, length, recurrance, priority, information, done, tags);
        }else{
            return new Task(name, priority, information, done, tags);
        }
    }
    
```
###### \java\seedu\address\ui\PersonCard.java
``` java
    @FXML
    public void initialize() {
        name.setText(person.getName().fullName);
        id.setText(displayedIndex + ". ");
        priority.setText(person.getPriority().toString());
        information.setText(person.getInformation().fullInformation);
        done.setText(person.getDoneFlag().toString());
        if(person.isDated()){
            ReadOnlyDatedTask datedTask = (ReadOnlyDatedTask) person;
            datetime.setText(datedTask.getDateTime().toString());
            length.setText(datedTask.getLength().toString());
            recurrance.setText(datedTask.getRecurrance().toString());
        }else{
            VBox sub = ((VBox) (datetime.getParent()));
            sub.getChildren().remove(datetime);
            sub.getChildren().remove(recurrance);
            sub.getChildren().remove(length);
            
        }
        tags.setText(person.tagsString());
        style();
    }
    
    public void style(){
        StringBuilder styleString = new StringBuilder();
        // Style based on property
        styleString.append(styler.getPriorityColour(person.getPriority().toString()));
        // Style based on done
        styleString.append(styler.getDoneColour(person.getDoneFlag().toString()));
        cardPane.setStyle(styleString.toString());
    }
    
```
###### \java\seedu\address\ui\TaskPropertyMapping.java
``` java
package seedu.address.ui;

import java.util.HashMap;

/*
 * Class for converting task properties to CSS style strings which
 * are used to style UI elements.
 * 
 * Task properties must be a string.
 * 
 * Styles are usually strings in the form:
 * style-name : value;
 * which can be easily applied by using setStyle();
 */

public class TaskPropertyMapping implements TaskStyleMapping{
    private final static String PROPERTY_BACKGROUND = "-fx-background-color";
    
    private final static PropertyMap priorityMap;
    private final static PropertyMap doneMap;
    
    private static TaskPropertyMapping instance = null;
    
    static {
        // Priority : Background color
        priorityMap = new PropertyMap(PROPERTY_BACKGROUND);
        priorityMap.addTo("VERYHIGH", "radial-gradient(radius 100%, #FFAAAA, #FF9999)");
        priorityMap.addTo("HIGH", "radial-gradient(radius 100%, #FFDDDD, #FFCCCC)");
        priorityMap.addTo("MEDIUM", "radial-gradient(radius 100%, #DDDDDD, #CCCCCC)");
        priorityMap.addTo("LOW", "radial-gradient(radius 100%, #D5FFD5, #C4EEC4)");
        priorityMap.addTo("VERYLOW", "radial-gradient(radius 100%, #95E195, #84D084)");
        
        // Done : Background color
        doneMap = new PropertyMap(PROPERTY_BACKGROUND);
        priorityMap.addTo("Done", "radial-gradient(radius 100%, #BAEFF4, #A9DEE3)");
    }
    
    // Singleton
    private TaskPropertyMapping(){}
    
    public static TaskPropertyMapping getInstance(){
        if(instance == null){
            instance = new TaskPropertyMapping();
        }
        return instance;
    }
    
    @Override
    public String getPriorityColour(String priority){
        return priorityMap.get(priority);
    }

    @Override
    public String getDoneColour(String done) {
        return doneMap.get(done);
    }
    
    /*
     * Wrapper class for a hash map which maps Task Property : CSS Style String.
     * Makes adding property constants easier.
     * Also, returns a default value if the requested property does not exist.
     */
    private static class PropertyMap{
        private final String property;
        public final static HashMap<String, String> map = new HashMap<String, String>();
        
        public PropertyMap(String property){
            this.property = property;
        }
        
        public void addTo(String key, String value){
            map.put(key, getStyleString(property, value));
        }
        
        public String get(String key){
            if(map.containsKey(key)){
                return map.get(key);
            }
            return ""; // No property
        }
    }
    
    /*
     * Converts a CSS property and value into the CSS style string format.
     */
    private static String getStyleString(String property, String value){
        return property + ": " + value + ";";
    }

}
```
###### \java\seedu\address\ui\TaskStyleMapping.java
``` java
package seedu.address.ui;

/*
 * API for a class that converts Task properties to CSS properties
 * to style.
 */
public interface TaskStyleMapping {
    /* Returns a colour style based on the Task's priority property.*/
    public String getPriorityColour(String priority);
    /* Returns a colour style based on the Task's done property.*/
    public String getDoneColour(String done);
}
```
###### \resources\view\DarkTheme.css
``` css
 * Many of the above properties were changed too
 * */

#cardPane {
    -fx-background-color: transparent;
    -fx-border-color: #A0A0A0;
    -fx-padding: 10;
    -fx-border-width: 2 2 2 2;
    -fx-border-radius: 30 0 30 0;
    -fx-border-insets: 5 10 5 10;
    -fx-background-insets: 5 10 5 10;
    -fx-background-radius: 30 0 30 0;
}

#commandTypeLabel {
    -fx-font-size: 11px;
    -fx-text-fill: #F70D1A;
}

#filterField, #personListPanel, #personWebpage {
    -fx-effect: innershadow(gaussian, black, 10, 0, 0, 0);
}

.list-cell:filled:selected:focused, .list-cell:filled:selected {
    -fx-background-color: #6F98E2;
}
```
